## 设计模式

### 1.单例模式

​	确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。 

### 2.工厂模式

​	定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。 

### 3.抽象工厂模式

​	为创建一组相关或相互依赖的对象提供一个接口，而且无须指定它们的具体类。 

### 4.模板方法模式

​	定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 

### 5.代理模式

​	为其他对象提供一种代理以控制对这个对象的访问。 

### 6.原型模式

​	用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 

### 7.装饰模式

​	动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活。 

### 8.策略模式

​	定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。 

### 9.适配器模式

​	将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。 

### 10.观察者模式

​	定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。 

## SpringAOP、IOC、DI应用的代码片段

```
SpringAOP
	AOP利用一种称为“横切”的技术，剖解开封装的对象内部，将那些影响多个类的公共行为封装到一个可重用模块，并将其名为方面(Aspect)。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑封装起来的部分。以便于减少系统的重复代码，降低模块间的耦合度，并有利于系统维护。
	@Aspect
	@Advice
IOC/DI
	IOC: Inversion of Control(控制反转)是一种设计思想，就是容器控制应用程序所需要外部资源的创建和管理，然后将其反转给应用程序。对象及其依赖对象的创建及维护都不需要在应用程序中实现，将其交给IOC容器去管理。传统的开发中，我们自己在对象内部创建依赖对象并注入当前对象，完成依赖关系的维护；对于IOC而言，它强调是将主动变为被动，由IOC容器来负责依赖对象的创建和查找，由IOC容器来进行注入组合对象，我们只需要在相关的配置文件中维护对象之间的依赖关系即可。
　　DI: Dependency Injection，即“依赖注入”。其实IOC和DI本就是同一个概念的两种不同的表述，应用程序依赖容器提供的外部对象，容器将其依赖的外部资源在运行期注入到应用程序中；某个对象被调用时，其所依赖的对象由容器注入。
	@Autowire
	@Resource
```

**原型模式（Prototype Pattern）**是指原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式主要适用于以下场景：

    	1、类初始化消耗资源较多。
    	2、new 产生的一个对象需要非常繁琐的过程（数据准备、访问权限等）
    	3、构造函数比较复杂。
    	4、循环体中生产大量对象时

​	**动态代理**

为什么JDK动态代理中要求目标类实现的接口数量不能超过65535个？

​		一个类中的方法最多为62235个，因为在类文件的记录中记录方法数量的是两个字节的大小字段，最多为65535。

​	**模板方法模式**

​	模板方法模式是类的行为模式。准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。这就是模板方法模式的用意。 模板模式除了继承以外，还可以通过实现接口来实现模板功能。

​	**装饰者模式和适配器模式**

​	装饰者模式和适配器模式对比：

​	装饰者和适配器模式都是包装模式（Wrapper Pattern），装饰者也是一种特殊的代理模式。

|      | 装饰者模式                                                   | 适配器模式                                                   |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 形式 | 是一种非常特别的适配器模式                                   | 没有层级关系，装饰器模式有层级关系                           |
| 定义 | 装饰者和被装饰者都实现同一个接口，主要目的是为了扩展之后依旧保留 OOP 关系。 | 适配器和被适配者没有必然的联系，通常是采用继承或代理的形式进行包装 |
| 关系 | 满足 is-a 的关系                                             | 满足 has-a 的关系                                            |
| 功能 | 注重覆盖、扩展                                               | 注重兼容、转换                                               |
| 设计 | 前置考虑                                                     | 后置考虑                                                     |

