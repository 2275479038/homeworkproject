## 设计模式

### 1.单例模式

​	确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。 

### 2.工厂模式

​	定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。 

### 3.抽象工厂模式

​	为创建一组相关或相互依赖的对象提供一个接口，而且无须指定它们的具体类。 

### 4.模板方法模式

​	定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 

### 5.代理模式

​	为其他对象提供一种代理以控制对这个对象的访问。 

### 6.原型模式

​	用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 

### 7.装饰模式

​	动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活。 

### 8.策略模式

​	定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。 

### 9.适配器模式

​	将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。 

### 10.观察者模式

​	定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。 

**原型模式（Prototype Pattern）**是指原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式主要适用于以下场景：

    	1、类初始化消耗资源较多。
    	2、new 产生的一个对象需要非常繁琐的过程（数据准备、访问权限等）
    	3、构造函数比较复杂。
    	4、循环体中生产大量对象时

​	**动态代理**

为什么JDK动态代理中要求目标类实现的接口数量不能超过65535个？

​		一个类中的方法最多为62235个，因为在类文件的记录中记录方法数量的是两个字节的大小字段，最多为65535。

​	**模板方法模式**

​	模板方法模式是类的行为模式。准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。这就是模板方法模式的用意。 模板模式除了继承以外，还可以通过实现接口来实现模板功能。

​	**装饰者模式和适配器模式**

​	装饰者模式和适配器模式对比：

​	装饰者和适配器模式都是包装模式（Wrapper Pattern），装饰者也是一种特殊的代理模式。

|      | 装饰者模式                                                   | 适配器模式                                                   |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 形式 | 是一种非常特别的适配器模式                                   | 没有层级关系，装饰器模式有层级关系                           |
| 定义 | 装饰者和被装饰者都实现同一个接口，主要目的是为了扩展之后依旧保留 OOP 关系。 | 适配器和被适配者没有必然的联系，通常是采用继承或代理的形式进行包装 |
| 关系 | 满足 is-a 的关系                                             | 满足 has-a 的关系                                            |
| 功能 | 注重覆盖、扩展                                               | 注重兼容、转换                                               |
| 设计 | 前置考虑                                                     | 后置考虑                                                     |

